#include "JoystickDriver.c" 
#pragma config(Sensor, S1,     touch,          sensorTouch)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

//all units in inches
float rotationdistance = 2;
//float circumference = 12;
int turnticks = 360;
int minDistance = 5;

void setMotors(int powerleft, int powerright){
	motor[motorB] = powerright;
	motor[motorC] = powerleft;
}

void moveDistance(float distancetogo){
	float ticksneeded = (distancetogo / (rotationdistance)) * 360;
	nMotorEncoderTarget[motorB] = ticksneeded;
	setMotors(100, 100);
	nSyncedTurnRatio = +100;
	while(nMotorEncoder[motorB] < ticksneeded){
	}
	setMotors(0, 0);
}

void turn(int ticks){
	nMotorEncoderTarget[motorB] = ticks;
	setMotors(100, 100);
	nSyncedTurnRatio = -100;
	while(nMotorEncoder[motorB] < ticks){
	}
	setMotors(0, 0);
}

/*
* Touch sensors have 2 states, these states are
* stored in SensorValue(touch). touch is the name of 
* the default sensor in this file
*/

bool checkIfTouching(){
	if (SensorValue(touch) == 1){ //on state
		return true;
	} else return false; 
}

void initBlockKick(){
	if (checkIfTouching() == true){
		turn(45); //this turned 45 degrees before ticks, not sure if will work now
	}
	
}

void initControl(){
	int threshold = 20;             /* Int 'threshold' will allow us to ignore low       */
                                  /* readings that keep our robot in perpetual motion. */

  while(true)                            // Infinite loop:
  {
    getJoystickSettings(joystick);
    if(abs(joystick.joy1_y2) > threshold)   // If the right analog stick's Y-axis readings are either above or below the threshold:
    {
      motor[motorB] = joystick.joy1_y2;         // Motor B is assigned a power level equal to the right analog stick's Y-axis reading.
    }
    else                                    // Else if the readings are within the threshold:
    {
      motor[motorB] = 0;                        // Motor B is stopped with a power level of 0.
    }


    if(abs(joystick.joy1_y1) > threshold)   // If the left analog stick's Y-axis readings are either above or below the threshold:
    {
      motor[motorC] = joystick.joy1_y1;         // Motor C is assigned a power level equal to the left analog stick's Y-axis reading.
    }
    else                                    // Else if the readings are within the threshold:
    {
      motor[motorC] = 0;                        // Motor C is stopped with a power level of 0.
    }
  }
}

/* 
* This is for the ultrasonic sensor,
* which has states from 0-255, which is 
* the distance in CM
* sonar is the default UV sensor here
*/

void stopMotors(){
	setMotors(0, 0);
}

void autonomus(){
	moveDistance(36);
	turn(360);
}

task main(){
	nSyncedMotors = synchBC;
	autonomus();
	while(true){
		initBlockKick();
	}
	
}
